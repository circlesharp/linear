# 大纲_线性代数
> **工具：Markdown语法** https://www.jianshu.com/p/191d1e21f7ed
> **工具：vscode 使用技巧**https://www.cnblogs.com/schut/p/10461840.html

## 第二章_向量

### 1. 向量就是一组数，这组数的含义由使用者来定义  
    最基本的出发点：表示方向；  
    起始点不重要，默认原点；  
    更加抽象的：n维向量（如果表示方向，最多3维就够了）；  
    不同的维度，就是不同的角度（评价房子的例子）；  
    **重点** 两种视角：空间中的一个点 / 有向线段（原点指向这个点的方向） ；  

### 2. 更严格的一些定义  
    标量：与向量对应的  
    代数：用符号代表数 -> 向量的符号画箭头 / 加粗 / 起始点上画箭头  
    行向量 vs 列向量（一般来说，指列向量） -> 列向量的表示：上标T（转置）  

### 3. 【实现】属于我们自己的向量类  
    **代码** Vector.py  
    **代码** main_vector.py  

### 4. 向量的基本运算
    1. 向量加法：  
        每一个分量（维度）分别相加  
        几何：平行四边形
    2. 数量乘法：  
        2 * (5, 2)T = (10, 4)T  
        k * (a, b)T = (k*a, k*b)T  

### 5. 【实现】向量的基本运算  
    **代码** Vector.p  
    **代码** main_vector.py  

### 6. 向量运算的基本性质  
     1. 交换律  
        uT + vT = vT + uT  
     2. 结合律  
        (uT + vT) + wT = uT + (vT + wT)  
     3. 数量乘法分配律  
        k * (uT + vT) = k * uT + k * vT  
        (k + c) * uT = k * uT + k * vT  
     4. 数量乘法结合律  
        （k * c) * uT = k * (c * uT)  

### 7. 零向量
    1. O：对于任意一个向量 uT ，都存在一个向量 O ，满足：uT + O = uT  
        不去定义什么是零向量，而是从推导一个性质出发  
        O的维度由它在的空间中决定；每一个空间中有惟一的零向量  
        **注意**O没有箭头，本质是一个点，是没有方向的  
    2. -uT：对于任意一个向量 uT ，都存在一个向量 -uT ，满足：uT + -uT = O  
        -uT唯一（使用反证法去证明：假设存在另一个 vT ，也满足：uT + vT = O）  
        且: -uT = -1 * uT  
        **注意**两种重要的方法：1. 反证法，2. 数学归纳法  

### 8. 【实现】零向量  
    **代码** Vector.py  
    **代码** main_vector.py  

### 9. 本章总结
    1. 两个视角
    2. 基本运算
    3. 基本性质
    4. 零向量


## 第三章_向量高级话题

### 1. 向量的规范化  
    1. 向量的模（向量的长度）  
        用 ||uT|| 表示（双竖线：二范数用双竖线表示/欧拉距离）  
    2. 向量的模的计算  
        uT = （u1, u2, ……, un)T  
        ||uT|| = (u1^2 + u2^2 + …… + un^2)^(1/2)  
    3. 单位向量(unit vector；向量的方向)  
        **重点**归一化/规范化/normalize：根据 向量uT 求 单位向量u_hat  
        **重点**单位向量长度已经不重要，方向才重要  
    4. 单位向量的计算  
        u_hat = uT / ||uT|| = (u1/||uT||, u2/||uT||, ……, un/||uT||)  
        u_hat = 1  
    5. 标准单位向量（Standard Unit Vector）  
        Standard Unit Vector 指向坐标轴的正方向  
        n维空间中，有n个 Standard Unit Vector  
        e1T = (1,0)  
        e2T = (0,1)  

### 2. 【实现】向量规范化  
    **代码** Vector.py  
    **代码** main_vector.py  

### 3. 向量的点乘与几何意义  
   1. uT.dot(vT) = u1*v1 + u2*v2 + …… + un*vn
   2. uT.dot(vT) = ||uT|| * ||vT|| * cos(Theta)
   3. 两个向量“相乘 (dot product)”，结果是一个数  
   4. 更严格的说法：点乘、内积

### 4. 向量点乘的直观理解
   1. 投影于其中一个向量上：uT.dot(vT) = ||uT|| * (||vT|| * cos(Theta) )
   2. 实质上，强调了向量的方向性；投影使得方向统一。
   3. 投影于坐标轴上：uT.dot(vT) = x1*x2 + y1*y2 + (x1*y2 + x2*y1)
   4. 但是(x1*y2 + x2*y1) = 0，因为cos(Theta)为0，彼此没有贡献。

### 5. 【实现】向量的点乘操作
    **代码** Vector.py  
    **代码** main_vector.py 

### 6. 向量点乘的意义
    1. 求两向量的夹角: cos(Theta) = uT.dot(vT) / (||uT|| * ||vT||)  
        如果 uT.dot(vT) > 0, 夹角锐角；  
        如果 uT.dot(vT) = 0, 向量垂直，例如标准单位向量；  
        如果 uT.dot(vT) < 0, 夹角钝角。  
    2. 判断两个向量的相似程度（推荐系统）
        例如，电影推荐，每个电影都是一个多维空间中的一个点  
        判断每个电影向量的夹角： 
            锐角 => 相似（越大越相似）  
            直角 => 无关  
            钝角 => 背离（越小越背离）  
    3. 几何计算
        投影点的坐标：P(vT) = d * u_hat = (uT.dot(vT) / ||uT||) * u_hat 

### 7. numpy中向量的基本使用

## 第四章_矩阵

### 1. 矩阵的概念  
    略

### 2. 实现矩阵
    **代码** Matrix.py  
    **代码** main_matirx.py

### 3. 矩阵的基本运算  
    1. 矩阵的加法：每一个对应元素相加 A + B  
    2. 矩阵的数量乘法：一个数与每一个元素相乘 k * A  
        例子：平均成绩： 1/2 * (A + B)  
        例子：图形的缩放：若P表示一个图形，2P表示该图形放大一倍
    3. 矩阵的基本运算性质
        1. A + B = B + A
        2. (A + B) + C = A + (B + C)
        3. 存在矩阵O，满足：A + O = A
        4. 存在矩阵-A，满足：A + (-A) = O
        5. -A 唯一；-A = -1 * A
        6. (ck)A = c(kA)
        7. k*(A + B) = kA + kB
        8. (c+k)A = cA + kA

### 4. 【实现】矩阵的基本运算  
    **代码** Matrix.py  
    **代码** main_matirx.py

### 5. 看待矩阵的另一个视角——一个系统  
    1. 视角01：矩阵是一个数据表格  
    2. 视角02：矩阵是一个系统 
        => 一个线性方程组 
        => 一个线性系统 
        => 系数就是矩阵，等式右边就是列向量

### 6. 矩阵和向量的乘法
    1. 系数矩阵 * 未知数列向量 = 结果列向量
        A * uT = bT
        就是矩阵的每一个行向量与未知数列向量进行点乘
        Matrix([vec1, vec2, …… ,vecn]) * vecuT = Vector([vec1.dot(vecu), vec2.dot(vecu), …… ,vecn.dot(vecu)])
    2. 矩阵A的列数 == 向量u元素
    3. 对于矩阵A的行数没有限制
        若矩阵行数为1，就是Vector(vec1.doc(vecu))
    4. 另一种理解：f(aT) = bT => 矩阵是向量的函数
        将向量 a 转化（映射）成为向量 b
        映射方法由矩阵 A 来定义的 => 矩阵是向量的函数

### 7. 矩阵和矩阵的乘法
    1. 基于矩阵*向量 => 矩阵*矩阵
        T * P = new_P
        Matrix(T) * Matrix(vec1T, vec2T, ……, vecnT) = Matrix((Matrix(T)*vec1)T, (Matrix(T)*vec2)T, ……， (Matrix(T)*vecn)T)
    2. T的列数 == P的行数
        => new_P 的 ij 位元素 = T的i行 * P的j列
        T.shape() = m*k,
        P.shape() = k*n
        (T*P).shape() = m*n
    3. 矩阵乘法不遵守交换律（可能是第一次发现不遵守交换律）

### 8. 【实现】矩阵的乘法  
    **代码** Matrix.py  
    **代码** main_matirx.py

### 9. 矩阵乘法的性质 & 矩阵的幂
    1. 矩阵乘法不遵守交换律
        => A.dot(B) != B.dot(A)
        => (A+B)**2 != A**2 + 2A.dot(B) + B**2
    2. 矩阵乘法遵守结合律、分配律
        => (A.dot(B)).dot(C) == A.dot(B.dot(C))
        => A.dot(B + C) == A.dot(B) + A.dot(C)
        => (B + C).dot(A) == B.dot(A) + C.dot(A)
    3. 对任意 r*c 矩阵A，存在 c*x 矩阵 O(Matrix.zero(c, x))，满足 A.dot(O) = O(Matrix.zero(r, x) 
        => A.dot(Matrix.zero(c,x)) = Matrix.zero(r,x)
    4. 矩阵的幂运算
        只有方阵才能进行幂运算
        A**k = A.dot(A.dot(……))  # k 个矩阵A 的点乘运算
        悬念： A**0 A**-1  # 下一章揭晓

### 10. 矩阵转置
    1. 数据科学中
        行：样本、点、记录
        列：特征、属性、维度
    2. 矩阵的转置
        行变成列，列变成行
    3. 转置性质
        ATT = A
        (A + B)T = AT + BT
        (k * A)T = k * AT
        (A * B)T = BT * AT 

### 11. 【实现】矩阵转置
    